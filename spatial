# This program solves the 2D heat equation.  It is based on an example
# from pp. 373-375 of MEJ Newman's book, Computational Physics.
# http://www-personal.umich.edu/~mejn/cp/

# David Feldman.  February 18, 2020

import numpy as np
import matplotlib.pylab as plt
import random as rand

# Set system parameters
#L = 0.01 # length of system
D = 0.01 # diffusivity
beta = 0.1
gamma = 1/6
InitialNitrogen= 1000


# Set algorithm parameters
Num = 10 # Number of elements in grid
# a = L/N We'll effectively take a = 1
DeltaT= 1e-4 # Time step
EndTime = 50
Steps = EndTime/DeltaT
NumPlots = 10 # This is the number of plots that will be saved.  Be careful!
Directory = "TempFigs" # Name of Directory where plots will be saved.
# If this directory doesn't already exist you might need to create it.

# Set Initial conditions.  Susceptibles, uniformly on grid
# Infectives at random with probability ProbSick
N = np.empty((Num+1,Num+1),float)
P = np.empty((Num+1,Num+1),float)
R = np.empty((Num+1,Num+1),float)

for i in range(1,Num):
    for j in range(1,Num):
        N[i,j] = InitialNitrogen + 1000*rand.random() - 1000
        P[i,j] = 100
        R[i,j] = 10
   
N_New = np.empty((Num+1,Num+1),float)
P_New = np.empty((Num+1,Num+1),float)
R_New = np.empty((Num+1,Num+1),float)

nitrogen0 = 100 #amount of nutrients (bottom prey)
P0 = 40 #amount pf plankton
R0 = 2 
nut_growth = 300
phyto_uptake = 0.8 #minimum: 0.6 if nut_growth is high (3 digits)
zoo_predation = 0.02 #doesnt work if not 0
phyto_growth = 0.8
phyto_death = 0.8
zoo_death = 0.7
zoo_birth = 0.1

# This function applies no-flux boundary conditions.  See discussion on
# the bottom of p. 236 of Guckeheimer and Ellner. I want the boundaries to
# be the same as their interior neighbor
def FixBCs(X):
    Num = len(X[0])-1
    X[0] = X[1]
    X[Num] = X[Num-1]
    X[0:Num+1,Num] = X[0:Num+1,Num-1]
    X[0:Num+1,0] = X[0:Num+1,1]
    return(X)

N = FixBCs(N)
P = FixBCs(P)
R = FixBCs(R)

def dN(N,P): 
    return(nut_growth - (phyto_uptake * P))
    
def dP(N,P, R):
    return(((phyto_growth*P) - (zoo_predation * R) - (P*phyto_death) ) ) #took out an N
    
def dR(N, P, R):
    return( (zoo_birth * R) - (R * zoo_death)) #where does the interaction term go?
    


# **************************************************************************


# Plot Initial Condition
plt.figure(0,figsize=(8,8))
plt.imshow(P,cmap="BuGn",vmin=0,vmax=10,origin="lower")
plt.colorbar()
plt.title("Time = 0")
plt.savefig(Directory+"/temp.0.png")
plt.close()

# calculate c used in the relaxation method 
c = DeltaT*D

q = int(Steps/NumPlots)

f = 1 # fig counter

for step in range(int(Steps)):
    #Calculate the new values of T
    N_New[1:Num,1:Num] = N[1:Num,1:Num] + DeltaT*dN(N[1:Num,1:Num],P[1:Num,1:Num]) + \
                     c*(N[2:Num+1,1:Num] + N[0:Num-1,1:Num] + N[1:Num,2:Num+1] \
                        + N[1:Num,0:Num-1] -4*N[1:Num,1:Num])
                     
    P_New[1:Num,1:Num] = P[1:Num,1:Num] + DeltaT*dP(N[1:Num,1:Num],P[1:Num,1:Num], R[1:Num,1:Num]) + \
                     c*(P[2:Num+1,1:Num] + P[0:Num-1,1:Num] + P[1:Num,2:Num+1] \
                        + P[1:Num,0:Num-1] -4*P[1:Num,1:Num])  
                     
    R_New[1:Num,1:Num] = R[1:Num,1:Num] + DeltaT*dR(N[1:Num,1:Num],P[1:Num,1:Num], R[1:Num,1:Num]) + \
                     c*(R[2:Num+1,1:Num] + R[0:Num-1,1:Num] + R[1:Num,2:Num+1] \
                        + R[1:Num,0:Num-1] -4*R[1:Num,1:Num])  
# ***************************************************************
# The above line is equivalent to the following nested for loops:    
#    for i in range(1,N):
#        for j in range(1,N):
#            T_New[i,j] = T[i,j] + \
#                         c*(T[i+1,j] + T[i-1,j] + 
#                         T[i,j+1] + T[i,j-1] - 4*T[i,j])
# ***************************************************************
    N_New = FixBCs(N_New)
    P_New = FixBCs(P_New)
    R_New = FixBCs(R_New)
    N,N_New = N_New, N # Swap arrays
    P,P_New = P_New, P # Swap arrays
    R,R_New = R_New, R

#    image.set_data(T)
#    title.set_text(time_template% (t*Delta_t))
    if (step%q == 0):
        print("I am making plot", f, "out of", NumPlots)
        plt.figure(f,figsize=(8,8))
        plt.imshow(P,cmap="BuGn",vmin=0, vmax = 1100, origin="lower")
        plt.title("Time = %.4fs"%(step*DeltaT))
        plt.colorbar()
        plt.savefig(Directory+"/temp."+str(f)+".png")
        plt.close()
        f += 1
   
print("I'm done now. Enjoy your plots.")
    



